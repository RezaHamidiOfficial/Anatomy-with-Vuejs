import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-CF3WPAMV.js";

// node_modules/@popperjs/core/lib/enums.js
var top, bottom, right, left, auto, basePlacements, start, end, clippingParents, viewport, popper, reference, variationPlacements, placements, beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite, modifierPhases;
var init_enums = __esm({
  "node_modules/@popperjs/core/lib/enums.js"() {
    top = "top";
    bottom = "bottom";
    right = "right";
    left = "left";
    auto = "auto";
    basePlacements = [top, bottom, right, left];
    start = "start";
    end = "end";
    clippingParents = "clippingParents";
    viewport = "viewport";
    popper = "popper";
    reference = "reference";
    variationPlacements = basePlacements.reduce(function(acc, placement) {
      return acc.concat([placement + "-" + start, placement + "-" + end]);
    }, []);
    placements = [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
      return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
    }, []);
    beforeRead = "beforeRead";
    read = "read";
    afterRead = "afterRead";
    beforeMain = "beforeMain";
    main = "main";
    afterMain = "afterMain";
    beforeWrite = "beforeWrite";
    write = "write";
    afterWrite = "afterWrite";
    modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
  }
});

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
var init_getNodeName = __esm({
  "node_modules/@popperjs/core/lib/dom-utils/getNodeName.js"() {
  }
});

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
var init_getWindow = __esm({
  "node_modules/@popperjs/core/lib/dom-utils/getWindow.js"() {
  }
});

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
var init_instanceOf = __esm({
  "node_modules/@popperjs/core/lib/dom-utils/instanceOf.js"() {
    init_getWindow();
  }
});

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default;
var init_applyStyles = __esm({
  "node_modules/@popperjs/core/lib/modifiers/applyStyles.js"() {
    init_getNodeName();
    init_instanceOf();
    applyStyles_default = {
      name: "applyStyles",
      enabled: true,
      phase: "write",
      fn: applyStyles,
      effect,
      requires: ["computeStyles"]
    };
  }
});

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
var init_getBasePlacement = __esm({
  "node_modules/@popperjs/core/lib/utils/getBasePlacement.js"() {
    init_enums();
  }
});

// node_modules/@popperjs/core/lib/utils/math.js
var max, min, round;
var init_math = __esm({
  "node_modules/@popperjs/core/lib/utils/math.js"() {
    max = Math.max;
    min = Math.min;
    round = Math.round;
  }
});

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element, includeScale) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  var rect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (isHTMLElement(element) && includeScale) {
    var offsetHeight = element.offsetHeight;
    var offsetWidth = element.offsetWidth;
    if (offsetWidth > 0) {
      scaleX = round(rect.width) / offsetWidth || 1;
    }
    if (offsetHeight > 0) {
      scaleY = round(rect.height) / offsetHeight || 1;
    }
  }
  return {
    width: rect.width / scaleX,
    height: rect.height / scaleY,
    top: rect.top / scaleY,
    right: rect.right / scaleX,
    bottom: rect.bottom / scaleY,
    left: rect.left / scaleX,
    x: rect.left / scaleX,
    y: rect.top / scaleY
  };
}
var init_getBoundingClientRect = __esm({
  "node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js"() {
    init_instanceOf();
    init_math();
  }
});

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}
var init_getLayoutRect = __esm({
  "node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js"() {
    init_getBoundingClientRect();
  }
});

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
var init_contains = __esm({
  "node_modules/@popperjs/core/lib/dom-utils/contains.js"() {
    init_instanceOf();
  }
});

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
var init_getComputedStyle = __esm({
  "node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js"() {
    init_getWindow();
  }
});

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
var init_isTableElement = __esm({
  "node_modules/@popperjs/core/lib/dom-utils/isTableElement.js"() {
    init_getNodeName();
  }
});

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}
var init_getDocumentElement = __esm({
  "node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js"() {
    init_instanceOf();
  }
});

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}
var init_getParentNode = __esm({
  "node_modules/@popperjs/core/lib/dom-utils/getParentNode.js"() {
    init_getNodeName();
    init_getDocumentElement();
    init_instanceOf();
  }
});

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle2(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
  var isIE = navigator.userAgent.indexOf("Trident") !== -1;
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle2(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle2(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
var init_getOffsetParent = __esm({
  "node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js"() {
    init_getWindow();
    init_getNodeName();
    init_getComputedStyle();
    init_instanceOf();
    init_isTableElement();
    init_getParentNode();
  }
});

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
var init_getMainAxisFromPlacement = __esm({
  "node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js"() {
  }
});

// node_modules/@popperjs/core/lib/utils/within.js
function within(min2, value, max2) {
  return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}
var init_within = __esm({
  "node_modules/@popperjs/core/lib/utils/within.js"() {
    init_math();
  }
});

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
var init_getFreshSideObject = __esm({
  "node_modules/@popperjs/core/lib/utils/getFreshSideObject.js"() {
  }
});

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
var init_mergePaddingObject = __esm({
  "node_modules/@popperjs/core/lib/utils/mergePaddingObject.js"() {
    init_getFreshSideObject();
  }
});

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}
var init_expandToHashMap = __esm({
  "node_modules/@popperjs/core/lib/utils/expandToHashMap.js"() {
  }
});

// node_modules/@popperjs/core/lib/modifiers/arrow.js
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (true) {
    if (!isHTMLElement(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "));
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    if (true) {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
    }
    return;
  }
  state.elements.arrow = arrowElement;
}
var toPaddingObject, arrow_default;
var init_arrow = __esm({
  "node_modules/@popperjs/core/lib/modifiers/arrow.js"() {
    init_getBasePlacement();
    init_getLayoutRect();
    init_contains();
    init_getOffsetParent();
    init_getMainAxisFromPlacement();
    init_within();
    init_mergePaddingObject();
    init_expandToHashMap();
    init_enums();
    init_instanceOf();
    toPaddingObject = function toPaddingObject2(padding, state) {
      padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
        placement: state.placement
      })) : padding;
      return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
    };
    arrow_default = {
      name: "arrow",
      enabled: true,
      phase: "main",
      fn: arrow,
      effect: effect2,
      requires: ["popperOffsets"],
      requiresIfExists: ["preventOverflow"]
    };
  }
});

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}
var init_getVariation = __esm({
  "node_modules/@popperjs/core/lib/utils/getVariation.js"() {
  }
});

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
function roundOffsetsByDPR(_ref) {
  var x = _ref.x, y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle2(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  if (true) {
    var transitionProperty = getComputedStyle2(state.elements.popper).transitionProperty || "";
    if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
    }
  }
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var unsetSides, computeStyles_default;
var init_computeStyles = __esm({
  "node_modules/@popperjs/core/lib/modifiers/computeStyles.js"() {
    init_enums();
    init_getOffsetParent();
    init_getWindow();
    init_getDocumentElement();
    init_getComputedStyle();
    init_getBasePlacement();
    init_getVariation();
    init_math();
    unsetSides = {
      top: "auto",
      right: "auto",
      bottom: "auto",
      left: "auto"
    };
    computeStyles_default = {
      name: "computeStyles",
      enabled: true,
      phase: "beforeWrite",
      fn: computeStyles,
      data: {}
    };
  }
});

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
function effect3(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var passive, eventListeners_default;
var init_eventListeners = __esm({
  "node_modules/@popperjs/core/lib/modifiers/eventListeners.js"() {
    init_getWindow();
    passive = {
      passive: true
    };
    eventListeners_default = {
      name: "eventListeners",
      enabled: true,
      phase: "write",
      fn: function fn() {
      },
      effect: effect3,
      data: {}
    };
  }
});

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}
var hash;
var init_getOppositePlacement = __esm({
  "node_modules/@popperjs/core/lib/utils/getOppositePlacement.js"() {
    hash = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom"
    };
  }
});

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash2[matched];
  });
}
var hash2;
var init_getOppositeVariationPlacement = __esm({
  "node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js"() {
    hash2 = {
      start: "end",
      end: "start"
    };
  }
});

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
var init_getWindowScroll = __esm({
  "node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js"() {
    init_getWindow();
  }
});

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
var init_getWindowScrollBarX = __esm({
  "node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js"() {
    init_getBoundingClientRect();
    init_getDocumentElement();
    init_getWindowScroll();
  }
});

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element),
    y
  };
}
var init_getViewportRect = __esm({
  "node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js"() {
    init_getWindow();
    init_getDocumentElement();
    init_getWindowScrollBarX();
  }
});

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle2(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
var init_getDocumentRect = __esm({
  "node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js"() {
    init_getDocumentElement();
    init_getComputedStyle();
    init_getWindowScrollBarX();
    init_getWindowScroll();
    init_math();
  }
});

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle2(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
var init_isScrollParent = __esm({
  "node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js"() {
    init_getComputedStyle();
  }
});

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}
var init_getScrollParent = __esm({
  "node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js"() {
    init_getParentNode();
    init_isScrollParent();
    init_getNodeName();
    init_instanceOf();
  }
});

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}
var init_listScrollParents = __esm({
  "node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js"() {
    init_getScrollParent();
    init_getParentNode();
    init_getWindow();
    init_isScrollParent();
  }
});

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
var init_rectToClientRect = __esm({
  "node_modules/@popperjs/core/lib/utils/rectToClientRect.js"() {
  }
});

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element) {
  var rect = getBoundingClientRect(element);
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
var init_getClippingRect = __esm({
  "node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js"() {
    init_enums();
    init_getViewportRect();
    init_getDocumentRect();
    init_listScrollParents();
    init_getOffsetParent();
    init_getDocumentElement();
    init_getComputedStyle();
    init_instanceOf();
    init_getBoundingClientRect();
    init_getParentNode();
    init_contains();
    init_getNodeName();
    init_rectToClientRect();
    init_math();
  }
});

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}
var init_computeOffsets = __esm({
  "node_modules/@popperjs/core/lib/utils/computeOffsets.js"() {
    init_getBasePlacement();
    init_getVariation();
    init_getMainAxisFromPlacement();
    init_enums();
  }
});

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}
var init_detectOverflow = __esm({
  "node_modules/@popperjs/core/lib/utils/detectOverflow.js"() {
    init_getClippingRect();
    init_getDocumentElement();
    init_getBoundingClientRect();
    init_computeOffsets();
    init_rectToClientRect();
    init_enums();
    init_instanceOf();
    init_mergePaddingObject();
    init_expandToHashMap();
  }
});

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
    if (true) {
      console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" "));
    }
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}
var init_computeAutoPlacement = __esm({
  "node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js"() {
    init_getVariation();
    init_enums();
    init_detectOverflow();
    init_getBasePlacement();
  }
});

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default;
var init_flip = __esm({
  "node_modules/@popperjs/core/lib/modifiers/flip.js"() {
    init_getOppositePlacement();
    init_getBasePlacement();
    init_getOppositeVariationPlacement();
    init_detectOverflow();
    init_computeAutoPlacement();
    init_enums();
    init_getVariation();
    flip_default = {
      name: "flip",
      enabled: true,
      phase: "main",
      fn: flip,
      requiresIfExists: ["offset"],
      data: {
        _skip: false
      }
    };
  }
});

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default;
var init_hide = __esm({
  "node_modules/@popperjs/core/lib/modifiers/hide.js"() {
    init_enums();
    init_detectOverflow();
    hide_default = {
      name: "hide",
      enabled: true,
      phase: "main",
      requiresIfExists: ["preventOverflow"],
      fn: hide
    };
  }
});

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset_default;
var init_offset = __esm({
  "node_modules/@popperjs/core/lib/modifiers/offset.js"() {
    init_getBasePlacement();
    init_enums();
    offset_default = {
      name: "offset",
      enabled: true,
      phase: "main",
      requires: ["popperOffsets"],
      fn: offset
    };
  }
});

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default;
var init_popperOffsets = __esm({
  "node_modules/@popperjs/core/lib/modifiers/popperOffsets.js"() {
    init_computeOffsets();
    popperOffsets_default = {
      name: "popperOffsets",
      enabled: true,
      phase: "read",
      fn: popperOffsets,
      data: {}
    };
  }
});

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
var init_getAltAxis = __esm({
  "node_modules/@popperjs/core/lib/utils/getAltAxis.js"() {
  }
});

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default;
var init_preventOverflow = __esm({
  "node_modules/@popperjs/core/lib/modifiers/preventOverflow.js"() {
    init_enums();
    init_getBasePlacement();
    init_getMainAxisFromPlacement();
    init_getAltAxis();
    init_within();
    init_getLayoutRect();
    init_getOffsetParent();
    init_detectOverflow();
    init_getVariation();
    init_getFreshSideObject();
    init_math();
    preventOverflow_default = {
      name: "preventOverflow",
      enabled: true,
      phase: "main",
      fn: preventOverflow,
      requiresIfExists: ["offset"]
    };
  }
});

// node_modules/@popperjs/core/lib/modifiers/index.js
var init_modifiers = __esm({
  "node_modules/@popperjs/core/lib/modifiers/index.js"() {
    init_applyStyles();
    init_arrow();
    init_computeStyles();
    init_eventListeners();
    init_flip();
    init_hide();
    init_offset();
    init_popperOffsets();
    init_preventOverflow();
  }
});

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
var init_getHTMLElementScroll = __esm({
  "node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js"() {
  }
});

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}
var init_getNodeScroll = __esm({
  "node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js"() {
    init_getWindowScroll();
    init_getWindow();
    init_instanceOf();
    init_getHTMLElementScroll();
  }
});

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
var init_getCompositeRect = __esm({
  "node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js"() {
    init_getBoundingClientRect();
    init_getNodeScroll();
    init_getNodeName();
    init_instanceOf();
    init_getWindowScrollBarX();
    init_getDocumentElement();
    init_isScrollParent();
    init_math();
  }
});

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
var init_orderModifiers = __esm({
  "node_modules/@popperjs/core/lib/utils/orderModifiers.js"() {
    init_enums();
  }
});

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}
var init_debounce = __esm({
  "node_modules/@popperjs/core/lib/utils/debounce.js"() {
  }
});

// node_modules/@popperjs/core/lib/utils/format.js
function format(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return [].concat(args).reduce(function(p, c) {
    return p.replace(/%s/, c);
  }, str);
}
var init_format = __esm({
  "node_modules/@popperjs/core/lib/utils/format.js"() {
  }
});

// node_modules/@popperjs/core/lib/utils/validateModifiers.js
function validateModifiers(modifiers) {
  modifiers.forEach(function(modifier) {
    [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value, index, self2) {
      return self2.indexOf(value) === index;
    }).forEach(function(key) {
      switch (key) {
        case "name":
          if (typeof modifier.name !== "string") {
            console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
          }
          break;
        case "enabled":
          if (typeof modifier.enabled !== "boolean") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
          }
          break;
        case "phase":
          if (modifierPhases.indexOf(modifier.phase) < 0) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
          }
          break;
        case "fn":
          if (typeof modifier.fn !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "effect":
          if (modifier.effect != null && typeof modifier.effect !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "requires":
          if (modifier.requires != null && !Array.isArray(modifier.requires)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
          }
          break;
        case "requiresIfExists":
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
          }
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s) {
            return '"' + s + '"';
          }).join(", ") + '; but "' + key + '" was provided.');
      }
      modifier.requires && modifier.requires.forEach(function(requirement) {
        if (modifiers.find(function(mod) {
          return mod.name === requirement;
        }) == null) {
          console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}
var INVALID_MODIFIER_ERROR, MISSING_DEPENDENCY_ERROR, VALID_PROPERTIES;
var init_validateModifiers = __esm({
  "node_modules/@popperjs/core/lib/utils/validateModifiers.js"() {
    init_format();
    init_enums();
    INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
    MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
    VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
  }
});

// node_modules/@popperjs/core/lib/utils/uniqueBy.js
function uniqueBy(arr, fn2) {
  var identifiers = /* @__PURE__ */ new Set();
  return arr.filter(function(item) {
    var identifier = fn2(item);
    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}
var init_uniqueBy = __esm({
  "node_modules/@popperjs/core/lib/utils/uniqueBy.js"() {
  }
});

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}
var init_mergeByName = __esm({
  "node_modules/@popperjs/core/lib/utils/mergeByName.js"() {
  }
});

// node_modules/@popperjs/core/lib/createPopper.js
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers3 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper4(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers3, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        if (true) {
          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
            var name = _ref.name;
            return name;
          });
          validateModifiers(modifiers);
          if (getBasePlacement(state.options.placement) === auto) {
            var flipModifier = state.orderedModifiers.find(function(_ref2) {
              var name = _ref2.name;
              return name === "flip";
            });
            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
            }
          }
          var _getComputedStyle = getComputedStyle2(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
          if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
          }
        }
        runModifierEffects();
        return instance.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          if (true) {
            console.error(INVALID_ELEMENT_ERROR);
          }
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (true) {
            __debug_loops__ += 1;
            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      if (true) {
        console.error(INVALID_ELEMENT_ERROR);
      }
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect4 = _ref3.effect;
        if (typeof effect4 === "function") {
          var cleanupFn = effect4({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var INVALID_ELEMENT_ERROR, INFINITE_LOOP_ERROR, DEFAULT_OPTIONS, createPopper;
var init_createPopper = __esm({
  "node_modules/@popperjs/core/lib/createPopper.js"() {
    init_getCompositeRect();
    init_getLayoutRect();
    init_listScrollParents();
    init_getOffsetParent();
    init_getComputedStyle();
    init_orderModifiers();
    init_debounce();
    init_validateModifiers();
    init_uniqueBy();
    init_getBasePlacement();
    init_mergeByName();
    init_detectOverflow();
    init_instanceOf();
    init_enums();
    INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
    INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
    DEFAULT_OPTIONS = {
      placement: "bottom",
      modifiers: [],
      strategy: "absolute"
    };
    createPopper = popperGenerator();
  }
});

// node_modules/@popperjs/core/lib/popper-lite.js
var defaultModifiers, createPopper2;
var init_popper_lite = __esm({
  "node_modules/@popperjs/core/lib/popper-lite.js"() {
    init_createPopper();
    init_eventListeners();
    init_popperOffsets();
    init_computeStyles();
    init_applyStyles();
    defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default];
    createPopper2 = popperGenerator({
      defaultModifiers
    });
  }
});

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers2, createPopper3;
var init_popper = __esm({
  "node_modules/@popperjs/core/lib/popper.js"() {
    init_createPopper();
    init_eventListeners();
    init_popperOffsets();
    init_computeStyles();
    init_applyStyles();
    init_offset();
    init_flip();
    init_preventOverflow();
    init_arrow();
    init_hide();
    init_popper_lite();
    init_modifiers();
    defaultModifiers2 = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
    createPopper3 = popperGenerator({
      defaultModifiers: defaultModifiers2
    });
  }
});

// node_modules/@popperjs/core/lib/index.js
var lib_exports = {};
__export(lib_exports, {
  afterMain: () => afterMain,
  afterRead: () => afterRead,
  afterWrite: () => afterWrite,
  applyStyles: () => applyStyles_default,
  arrow: () => arrow_default,
  auto: () => auto,
  basePlacements: () => basePlacements,
  beforeMain: () => beforeMain,
  beforeRead: () => beforeRead,
  beforeWrite: () => beforeWrite,
  bottom: () => bottom,
  clippingParents: () => clippingParents,
  computeStyles: () => computeStyles_default,
  createPopper: () => createPopper3,
  createPopperBase: () => createPopper,
  createPopperLite: () => createPopper2,
  detectOverflow: () => detectOverflow,
  end: () => end,
  eventListeners: () => eventListeners_default,
  flip: () => flip_default,
  hide: () => hide_default,
  left: () => left,
  main: () => main,
  modifierPhases: () => modifierPhases,
  offset: () => offset_default,
  placements: () => placements,
  popper: () => popper,
  popperGenerator: () => popperGenerator,
  popperOffsets: () => popperOffsets_default,
  preventOverflow: () => preventOverflow_default,
  read: () => read,
  reference: () => reference,
  right: () => right,
  start: () => start,
  top: () => top,
  variationPlacements: () => variationPlacements,
  viewport: () => viewport,
  write: () => write
});
var init_lib = __esm({
  "node_modules/@popperjs/core/lib/index.js"() {
    init_enums();
    init_modifiers();
    init_createPopper();
    init_popper();
    init_popper_lite();
  }
});

// node_modules/bootstrap/dist/js/bootstrap.min.js
var require_bootstrap_min = __commonJS({
  "node_modules/bootstrap/dist/js/bootstrap.min.js"(exports, module) {
    !function(t, e) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = e((init_lib(), __toCommonJS(lib_exports))) : "function" == typeof define && define.amd ? define(["@popperjs/core"], e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).bootstrap = e(t.Popper);
    }(exports, function(t) {
      "use strict";
      function e(t2) {
        if (t2 && t2.__esModule)
          return t2;
        const e2 = /* @__PURE__ */ Object.create(null);
        if (t2) {
          for (const i2 in t2)
            if ("default" !== i2) {
              const s2 = Object.getOwnPropertyDescriptor(t2, i2);
              Object.defineProperty(e2, i2, s2.get ? s2 : { enumerable: true, get: () => t2[i2] });
            }
        }
        return e2.default = t2, Object.freeze(e2);
      }
      const i = e(t), s = "transitionend", n = (t2) => {
        let e2 = t2.getAttribute("data-bs-target");
        if (!e2 || "#" === e2) {
          let i2 = t2.getAttribute("href");
          if (!i2 || !i2.includes("#") && !i2.startsWith("."))
            return null;
          i2.includes("#") && !i2.startsWith("#") && (i2 = `#${i2.split("#")[1]}`), e2 = i2 && "#" !== i2 ? i2.trim() : null;
        }
        return e2;
      }, o = (t2) => {
        const e2 = n(t2);
        return e2 && document.querySelector(e2) ? e2 : null;
      }, r = (t2) => {
        const e2 = n(t2);
        return e2 ? document.querySelector(e2) : null;
      }, a = (t2) => {
        t2.dispatchEvent(new Event(s));
      }, l = (t2) => !(!t2 || "object" != typeof t2) && (void 0 !== t2.jquery && (t2 = t2[0]), void 0 !== t2.nodeType), c = (t2) => l(t2) ? t2.jquery ? t2[0] : t2 : "string" == typeof t2 && t2.length > 0 ? document.querySelector(t2) : null, h = (t2, e2, i2) => {
        Object.keys(i2).forEach((s2) => {
          const n2 = i2[s2], o2 = e2[s2], r2 = o2 && l(o2) ? "element" : null == (a2 = o2) ? `${a2}` : {}.toString.call(a2).match(/\s([a-z]+)/i)[1].toLowerCase();
          var a2;
          if (!new RegExp(n2).test(r2))
            throw new TypeError(`${t2.toUpperCase()}: Option "${s2}" provided type "${r2}" but expected type "${n2}".`);
        });
      }, d = (t2) => !(!l(t2) || 0 === t2.getClientRects().length) && "visible" === getComputedStyle(t2).getPropertyValue("visibility"), u = (t2) => !t2 || t2.nodeType !== Node.ELEMENT_NODE || !!t2.classList.contains("disabled") || (void 0 !== t2.disabled ? t2.disabled : t2.hasAttribute("disabled") && "false" !== t2.getAttribute("disabled")), g = (t2) => {
        if (!document.documentElement.attachShadow)
          return null;
        if ("function" == typeof t2.getRootNode) {
          const e2 = t2.getRootNode();
          return e2 instanceof ShadowRoot ? e2 : null;
        }
        return t2 instanceof ShadowRoot ? t2 : t2.parentNode ? g(t2.parentNode) : null;
      }, _ = () => {
      }, f = (t2) => {
        t2.offsetHeight;
      }, p = () => {
        const { jQuery: t2 } = window;
        return t2 && !document.body.hasAttribute("data-bs-no-jquery") ? t2 : null;
      }, m = [], b = () => "rtl" === document.documentElement.dir, v = (t2) => {
        var e2;
        e2 = () => {
          const e3 = p();
          if (e3) {
            const i2 = t2.NAME, s2 = e3.fn[i2];
            e3.fn[i2] = t2.jQueryInterface, e3.fn[i2].Constructor = t2, e3.fn[i2].noConflict = () => (e3.fn[i2] = s2, t2.jQueryInterface);
          }
        }, "loading" === document.readyState ? (m.length || document.addEventListener("DOMContentLoaded", () => {
          m.forEach((t3) => t3());
        }), m.push(e2)) : e2();
      }, y = (t2) => {
        "function" == typeof t2 && t2();
      }, E = (t2, e2, i2 = true) => {
        if (!i2)
          return void y(t2);
        const n2 = ((t3) => {
          if (!t3)
            return 0;
          let { transitionDuration: e3, transitionDelay: i3 } = window.getComputedStyle(t3);
          const s2 = Number.parseFloat(e3), n3 = Number.parseFloat(i3);
          return s2 || n3 ? (e3 = e3.split(",")[0], i3 = i3.split(",")[0], 1e3 * (Number.parseFloat(e3) + Number.parseFloat(i3))) : 0;
        })(e2) + 5;
        let o2 = false;
        const r2 = ({ target: i3 }) => {
          i3 === e2 && (o2 = true, e2.removeEventListener(s, r2), y(t2));
        };
        e2.addEventListener(s, r2), setTimeout(() => {
          o2 || a(e2);
        }, n2);
      }, w = (t2, e2, i2, s2) => {
        let n2 = t2.indexOf(e2);
        if (-1 === n2)
          return t2[!i2 && s2 ? t2.length - 1 : 0];
        const o2 = t2.length;
        return n2 += i2 ? 1 : -1, s2 && (n2 = (n2 + o2) % o2), t2[Math.max(0, Math.min(n2, o2 - 1))];
      }, A = /[^.]*(?=\..*)\.|.*/, T = /\..*/, C = /::\d+$/, k = {};
      let L = 1;
      const S = { mouseenter: "mouseover", mouseleave: "mouseout" }, O = /^(mouseenter|mouseleave)/i, N = /* @__PURE__ */ new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);
      function D(t2, e2) {
        return e2 && `${e2}::${L++}` || t2.uidEvent || L++;
      }
      function I(t2) {
        const e2 = D(t2);
        return t2.uidEvent = e2, k[e2] = k[e2] || {}, k[e2];
      }
      function P(t2, e2, i2 = null) {
        const s2 = Object.keys(t2);
        for (let n2 = 0, o2 = s2.length; n2 < o2; n2++) {
          const o3 = t2[s2[n2]];
          if (o3.originalHandler === e2 && o3.delegationSelector === i2)
            return o3;
        }
        return null;
      }
      function x(t2, e2, i2) {
        const s2 = "string" == typeof e2, n2 = s2 ? i2 : e2;
        let o2 = H(t2);
        return N.has(o2) || (o2 = t2), [s2, n2, o2];
      }
      function M(t2, e2, i2, s2, n2) {
        if ("string" != typeof e2 || !t2)
          return;
        if (i2 || (i2 = s2, s2 = null), O.test(e2)) {
          const t3 = (t4) => function(e3) {
            if (!e3.relatedTarget || e3.relatedTarget !== e3.delegateTarget && !e3.delegateTarget.contains(e3.relatedTarget))
              return t4.call(this, e3);
          };
          s2 ? s2 = t3(s2) : i2 = t3(i2);
        }
        const [o2, r2, a2] = x(e2, i2, s2), l2 = I(t2), c2 = l2[a2] || (l2[a2] = {}), h2 = P(c2, r2, o2 ? i2 : null);
        if (h2)
          return void (h2.oneOff = h2.oneOff && n2);
        const d2 = D(r2, e2.replace(A, "")), u2 = o2 ? function(t3, e3, i3) {
          return function s3(n3) {
            const o3 = t3.querySelectorAll(e3);
            for (let { target: r3 } = n3; r3 && r3 !== this; r3 = r3.parentNode)
              for (let a3 = o3.length; a3--; )
                if (o3[a3] === r3)
                  return n3.delegateTarget = r3, s3.oneOff && $.off(t3, n3.type, e3, i3), i3.apply(r3, [n3]);
            return null;
          };
        }(t2, i2, s2) : function(t3, e3) {
          return function i3(s3) {
            return s3.delegateTarget = t3, i3.oneOff && $.off(t3, s3.type, e3), e3.apply(t3, [s3]);
          };
        }(t2, i2);
        u2.delegationSelector = o2 ? i2 : null, u2.originalHandler = r2, u2.oneOff = n2, u2.uidEvent = d2, c2[d2] = u2, t2.addEventListener(a2, u2, o2);
      }
      function j(t2, e2, i2, s2, n2) {
        const o2 = P(e2[i2], s2, n2);
        o2 && (t2.removeEventListener(i2, o2, Boolean(n2)), delete e2[i2][o2.uidEvent]);
      }
      function H(t2) {
        return t2 = t2.replace(T, ""), S[t2] || t2;
      }
      const $ = { on(t2, e2, i2, s2) {
        M(t2, e2, i2, s2, false);
      }, one(t2, e2, i2, s2) {
        M(t2, e2, i2, s2, true);
      }, off(t2, e2, i2, s2) {
        if ("string" != typeof e2 || !t2)
          return;
        const [n2, o2, r2] = x(e2, i2, s2), a2 = r2 !== e2, l2 = I(t2), c2 = e2.startsWith(".");
        if (void 0 !== o2) {
          if (!l2 || !l2[r2])
            return;
          return void j(t2, l2, r2, o2, n2 ? i2 : null);
        }
        c2 && Object.keys(l2).forEach((i3) => {
          !function(t3, e3, i4, s3) {
            const n3 = e3[i4] || {};
            Object.keys(n3).forEach((o3) => {
              if (o3.includes(s3)) {
                const s4 = n3[o3];
                j(t3, e3, i4, s4.originalHandler, s4.delegationSelector);
              }
            });
          }(t2, l2, i3, e2.slice(1));
        });
        const h2 = l2[r2] || {};
        Object.keys(h2).forEach((i3) => {
          const s3 = i3.replace(C, "");
          if (!a2 || e2.includes(s3)) {
            const e3 = h2[i3];
            j(t2, l2, r2, e3.originalHandler, e3.delegationSelector);
          }
        });
      }, trigger(t2, e2, i2) {
        if ("string" != typeof e2 || !t2)
          return null;
        const s2 = p(), n2 = H(e2), o2 = e2 !== n2, r2 = N.has(n2);
        let a2, l2 = true, c2 = true, h2 = false, d2 = null;
        return o2 && s2 && (a2 = s2.Event(e2, i2), s2(t2).trigger(a2), l2 = !a2.isPropagationStopped(), c2 = !a2.isImmediatePropagationStopped(), h2 = a2.isDefaultPrevented()), r2 ? (d2 = document.createEvent("HTMLEvents"), d2.initEvent(n2, l2, true)) : d2 = new CustomEvent(e2, { bubbles: l2, cancelable: true }), void 0 !== i2 && Object.keys(i2).forEach((t3) => {
          Object.defineProperty(d2, t3, { get: () => i2[t3] });
        }), h2 && d2.preventDefault(), c2 && t2.dispatchEvent(d2), d2.defaultPrevented && void 0 !== a2 && a2.preventDefault(), d2;
      } }, B = /* @__PURE__ */ new Map(), z = { set(t2, e2, i2) {
        B.has(t2) || B.set(t2, /* @__PURE__ */ new Map());
        const s2 = B.get(t2);
        s2.has(e2) || 0 === s2.size ? s2.set(e2, i2) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(s2.keys())[0]}.`);
      }, get: (t2, e2) => B.has(t2) && B.get(t2).get(e2) || null, remove(t2, e2) {
        if (!B.has(t2))
          return;
        const i2 = B.get(t2);
        i2.delete(e2), 0 === i2.size && B.delete(t2);
      } };
      class R {
        constructor(t2) {
          (t2 = c(t2)) && (this._element = t2, z.set(this._element, this.constructor.DATA_KEY, this));
        }
        dispose() {
          z.remove(this._element, this.constructor.DATA_KEY), $.off(this._element, this.constructor.EVENT_KEY), Object.getOwnPropertyNames(this).forEach((t2) => {
            this[t2] = null;
          });
        }
        _queueCallback(t2, e2, i2 = true) {
          E(t2, e2, i2);
        }
        static getInstance(t2) {
          return z.get(c(t2), this.DATA_KEY);
        }
        static getOrCreateInstance(t2, e2 = {}) {
          return this.getInstance(t2) || new this(t2, "object" == typeof e2 ? e2 : null);
        }
        static get VERSION() {
          return "5.1.3";
        }
        static get NAME() {
          throw new Error('You have to implement the static method "NAME", for each component!');
        }
        static get DATA_KEY() {
          return `bs.${this.NAME}`;
        }
        static get EVENT_KEY() {
          return `.${this.DATA_KEY}`;
        }
      }
      const F = (t2, e2 = "hide") => {
        const i2 = `click.dismiss${t2.EVENT_KEY}`, s2 = t2.NAME;
        $.on(document, i2, `[data-bs-dismiss="${s2}"]`, function(i3) {
          if (["A", "AREA"].includes(this.tagName) && i3.preventDefault(), u(this))
            return;
          const n2 = r(this) || this.closest(`.${s2}`);
          t2.getOrCreateInstance(n2)[e2]();
        });
      };
      class q extends R {
        static get NAME() {
          return "alert";
        }
        close() {
          if ($.trigger(this._element, "close.bs.alert").defaultPrevented)
            return;
          this._element.classList.remove("show");
          const t2 = this._element.classList.contains("fade");
          this._queueCallback(() => this._destroyElement(), this._element, t2);
        }
        _destroyElement() {
          this._element.remove(), $.trigger(this._element, "closed.bs.alert"), this.dispose();
        }
        static jQueryInterface(t2) {
          return this.each(function() {
            const e2 = q.getOrCreateInstance(this);
            if ("string" == typeof t2) {
              if (void 0 === e2[t2] || t2.startsWith("_") || "constructor" === t2)
                throw new TypeError(`No method named "${t2}"`);
              e2[t2](this);
            }
          });
        }
      }
      F(q, "close"), v(q);
      const W = '[data-bs-toggle="button"]';
      class U extends R {
        static get NAME() {
          return "button";
        }
        toggle() {
          this._element.setAttribute("aria-pressed", this._element.classList.toggle("active"));
        }
        static jQueryInterface(t2) {
          return this.each(function() {
            const e2 = U.getOrCreateInstance(this);
            "toggle" === t2 && e2[t2]();
          });
        }
      }
      function K(t2) {
        return "true" === t2 || "false" !== t2 && (t2 === Number(t2).toString() ? Number(t2) : "" === t2 || "null" === t2 ? null : t2);
      }
      function V(t2) {
        return t2.replace(/[A-Z]/g, (t3) => `-${t3.toLowerCase()}`);
      }
      $.on(document, "click.bs.button.data-api", W, (t2) => {
        t2.preventDefault();
        const e2 = t2.target.closest(W);
        U.getOrCreateInstance(e2).toggle();
      }), v(U);
      const X = { setDataAttribute(t2, e2, i2) {
        t2.setAttribute(`data-bs-${V(e2)}`, i2);
      }, removeDataAttribute(t2, e2) {
        t2.removeAttribute(`data-bs-${V(e2)}`);
      }, getDataAttributes(t2) {
        if (!t2)
          return {};
        const e2 = {};
        return Object.keys(t2.dataset).filter((t3) => t3.startsWith("bs")).forEach((i2) => {
          let s2 = i2.replace(/^bs/, "");
          s2 = s2.charAt(0).toLowerCase() + s2.slice(1, s2.length), e2[s2] = K(t2.dataset[i2]);
        }), e2;
      }, getDataAttribute: (t2, e2) => K(t2.getAttribute(`data-bs-${V(e2)}`)), offset(t2) {
        const e2 = t2.getBoundingClientRect();
        return { top: e2.top + window.pageYOffset, left: e2.left + window.pageXOffset };
      }, position: (t2) => ({ top: t2.offsetTop, left: t2.offsetLeft }) }, Y = { find: (t2, e2 = document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(e2, t2)), findOne: (t2, e2 = document.documentElement) => Element.prototype.querySelector.call(e2, t2), children: (t2, e2) => [].concat(...t2.children).filter((t3) => t3.matches(e2)), parents(t2, e2) {
        const i2 = [];
        let s2 = t2.parentNode;
        for (; s2 && s2.nodeType === Node.ELEMENT_NODE && 3 !== s2.nodeType; )
          s2.matches(e2) && i2.push(s2), s2 = s2.parentNode;
        return i2;
      }, prev(t2, e2) {
        let i2 = t2.previousElementSibling;
        for (; i2; ) {
          if (i2.matches(e2))
            return [i2];
          i2 = i2.previousElementSibling;
        }
        return [];
      }, next(t2, e2) {
        let i2 = t2.nextElementSibling;
        for (; i2; ) {
          if (i2.matches(e2))
            return [i2];
          i2 = i2.nextElementSibling;
        }
        return [];
      }, focusableChildren(t2) {
        const e2 = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map((t3) => `${t3}:not([tabindex^="-"])`).join(", ");
        return this.find(e2, t2).filter((t3) => !u(t3) && d(t3));
      } }, Q = "carousel", G = { interval: 5e3, keyboard: true, slide: false, pause: "hover", wrap: true, touch: true }, Z = { interval: "(number|boolean)", keyboard: "boolean", slide: "(boolean|string)", pause: "(string|boolean)", wrap: "boolean", touch: "boolean" }, J = "next", tt = "prev", et = "left", it = "right", st = { ArrowLeft: it, ArrowRight: et }, nt = "slid.bs.carousel", ot = "active", rt = ".active.carousel-item";
      class at extends R {
        constructor(t2, e2) {
          super(t2), this._items = null, this._interval = null, this._activeElement = null, this._isPaused = false, this._isSliding = false, this.touchTimeout = null, this.touchStartX = 0, this.touchDeltaX = 0, this._config = this._getConfig(e2), this._indicatorsElement = Y.findOne(".carousel-indicators", this._element), this._touchSupported = "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0, this._pointerEvent = Boolean(window.PointerEvent), this._addEventListeners();
        }
        static get Default() {
          return G;
        }
        static get NAME() {
          return Q;
        }
        next() {
          this._slide(J);
        }
        nextWhenVisible() {
          !document.hidden && d(this._element) && this.next();
        }
        prev() {
          this._slide(tt);
        }
        pause(t2) {
          t2 || (this._isPaused = true), Y.findOne(".carousel-item-next, .carousel-item-prev", this._element) && (a(this._element), this.cycle(true)), clearInterval(this._interval), this._interval = null;
        }
        cycle(t2) {
          t2 || (this._isPaused = false), this._interval && (clearInterval(this._interval), this._interval = null), this._config && this._config.interval && !this._isPaused && (this._updateInterval(), this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval));
        }
        to(t2) {
          this._activeElement = Y.findOne(rt, this._element);
          const e2 = this._getItemIndex(this._activeElement);
          if (t2 > this._items.length - 1 || t2 < 0)
            return;
          if (this._isSliding)
            return void $.one(this._element, nt, () => this.to(t2));
          if (e2 === t2)
            return this.pause(), void this.cycle();
          const i2 = t2 > e2 ? J : tt;
          this._slide(i2, this._items[t2]);
        }
        _getConfig(t2) {
          return t2 = { ...G, ...X.getDataAttributes(this._element), ..."object" == typeof t2 ? t2 : {} }, h(Q, t2, Z), t2;
        }
        _handleSwipe() {
          const t2 = Math.abs(this.touchDeltaX);
          if (t2 <= 40)
            return;
          const e2 = t2 / this.touchDeltaX;
          this.touchDeltaX = 0, e2 && this._slide(e2 > 0 ? it : et);
        }
        _addEventListeners() {
          this._config.keyboard && $.on(this._element, "keydown.bs.carousel", (t2) => this._keydown(t2)), "hover" === this._config.pause && ($.on(this._element, "mouseenter.bs.carousel", (t2) => this.pause(t2)), $.on(this._element, "mouseleave.bs.carousel", (t2) => this.cycle(t2))), this._config.touch && this._touchSupported && this._addTouchEventListeners();
        }
        _addTouchEventListeners() {
          const t2 = (t3) => this._pointerEvent && ("pen" === t3.pointerType || "touch" === t3.pointerType), e2 = (e3) => {
            t2(e3) ? this.touchStartX = e3.clientX : this._pointerEvent || (this.touchStartX = e3.touches[0].clientX);
          }, i2 = (t3) => {
            this.touchDeltaX = t3.touches && t3.touches.length > 1 ? 0 : t3.touches[0].clientX - this.touchStartX;
          }, s2 = (e3) => {
            t2(e3) && (this.touchDeltaX = e3.clientX - this.touchStartX), this._handleSwipe(), "hover" === this._config.pause && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout((t3) => this.cycle(t3), 500 + this._config.interval));
          };
          Y.find(".carousel-item img", this._element).forEach((t3) => {
            $.on(t3, "dragstart.bs.carousel", (t4) => t4.preventDefault());
          }), this._pointerEvent ? ($.on(this._element, "pointerdown.bs.carousel", (t3) => e2(t3)), $.on(this._element, "pointerup.bs.carousel", (t3) => s2(t3)), this._element.classList.add("pointer-event")) : ($.on(this._element, "touchstart.bs.carousel", (t3) => e2(t3)), $.on(this._element, "touchmove.bs.carousel", (t3) => i2(t3)), $.on(this._element, "touchend.bs.carousel", (t3) => s2(t3)));
        }
        _keydown(t2) {
          if (/input|textarea/i.test(t2.target.tagName))
            return;
          const e2 = st[t2.key];
          e2 && (t2.preventDefault(), this._slide(e2));
        }
        _getItemIndex(t2) {
          return this._items = t2 && t2.parentNode ? Y.find(".carousel-item", t2.parentNode) : [], this._items.indexOf(t2);
        }
        _getItemByOrder(t2, e2) {
          const i2 = t2 === J;
          return w(this._items, e2, i2, this._config.wrap);
        }
        _triggerSlideEvent(t2, e2) {
          const i2 = this._getItemIndex(t2), s2 = this._getItemIndex(Y.findOne(rt, this._element));
          return $.trigger(this._element, "slide.bs.carousel", { relatedTarget: t2, direction: e2, from: s2, to: i2 });
        }
        _setActiveIndicatorElement(t2) {
          if (this._indicatorsElement) {
            const e2 = Y.findOne(".active", this._indicatorsElement);
            e2.classList.remove(ot), e2.removeAttribute("aria-current");
            const i2 = Y.find("[data-bs-target]", this._indicatorsElement);
            for (let e3 = 0; e3 < i2.length; e3++)
              if (Number.parseInt(i2[e3].getAttribute("data-bs-slide-to"), 10) === this._getItemIndex(t2)) {
                i2[e3].classList.add(ot), i2[e3].setAttribute("aria-current", "true");
                break;
              }
          }
        }
        _updateInterval() {
          const t2 = this._activeElement || Y.findOne(rt, this._element);
          if (!t2)
            return;
          const e2 = Number.parseInt(t2.getAttribute("data-bs-interval"), 10);
          e2 ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, this._config.interval = e2) : this._config.interval = this._config.defaultInterval || this._config.interval;
        }
        _slide(t2, e2) {
          const i2 = this._directionToOrder(t2), s2 = Y.findOne(rt, this._element), n2 = this._getItemIndex(s2), o2 = e2 || this._getItemByOrder(i2, s2), r2 = this._getItemIndex(o2), a2 = Boolean(this._interval), l2 = i2 === J, c2 = l2 ? "carousel-item-start" : "carousel-item-end", h2 = l2 ? "carousel-item-next" : "carousel-item-prev", d2 = this._orderToDirection(i2);
          if (o2 && o2.classList.contains(ot))
            return void (this._isSliding = false);
          if (this._isSliding)
            return;
          if (this._triggerSlideEvent(o2, d2).defaultPrevented)
            return;
          if (!s2 || !o2)
            return;
          this._isSliding = true, a2 && this.pause(), this._setActiveIndicatorElement(o2), this._activeElement = o2;
          const u2 = () => {
            $.trigger(this._element, nt, { relatedTarget: o2, direction: d2, from: n2, to: r2 });
          };
          if (this._element.classList.contains("slide")) {
            o2.classList.add(h2), f(o2), s2.classList.add(c2), o2.classList.add(c2);
            const t3 = () => {
              o2.classList.remove(c2, h2), o2.classList.add(ot), s2.classList.remove(ot, h2, c2), this._isSliding = false, setTimeout(u2, 0);
            };
            this._queueCallback(t3, s2, true);
          } else
            s2.classList.remove(ot), o2.classList.add(ot), this._isSliding = false, u2();
          a2 && this.cycle();
        }
        _directionToOrder(t2) {
          return [it, et].includes(t2) ? b() ? t2 === et ? tt : J : t2 === et ? J : tt : t2;
        }
        _orderToDirection(t2) {
          return [J, tt].includes(t2) ? b() ? t2 === tt ? et : it : t2 === tt ? it : et : t2;
        }
        static carouselInterface(t2, e2) {
          const i2 = at.getOrCreateInstance(t2, e2);
          let { _config: s2 } = i2;
          "object" == typeof e2 && (s2 = { ...s2, ...e2 });
          const n2 = "string" == typeof e2 ? e2 : s2.slide;
          if ("number" == typeof e2)
            i2.to(e2);
          else if ("string" == typeof n2) {
            if (void 0 === i2[n2])
              throw new TypeError(`No method named "${n2}"`);
            i2[n2]();
          } else
            s2.interval && s2.ride && (i2.pause(), i2.cycle());
        }
        static jQueryInterface(t2) {
          return this.each(function() {
            at.carouselInterface(this, t2);
          });
        }
        static dataApiClickHandler(t2) {
          const e2 = r(this);
          if (!e2 || !e2.classList.contains("carousel"))
            return;
          const i2 = { ...X.getDataAttributes(e2), ...X.getDataAttributes(this) }, s2 = this.getAttribute("data-bs-slide-to");
          s2 && (i2.interval = false), at.carouselInterface(e2, i2), s2 && at.getInstance(e2).to(s2), t2.preventDefault();
        }
      }
      $.on(document, "click.bs.carousel.data-api", "[data-bs-slide], [data-bs-slide-to]", at.dataApiClickHandler), $.on(window, "load.bs.carousel.data-api", () => {
        const t2 = Y.find('[data-bs-ride="carousel"]');
        for (let e2 = 0, i2 = t2.length; e2 < i2; e2++)
          at.carouselInterface(t2[e2], at.getInstance(t2[e2]));
      }), v(at);
      const lt = "collapse", ct = { toggle: true, parent: null }, ht = { toggle: "boolean", parent: "(null|element)" }, dt = "show", ut = "collapse", gt = "collapsing", _t = "collapsed", ft = ":scope .collapse .collapse", pt = '[data-bs-toggle="collapse"]';
      class mt extends R {
        constructor(t2, e2) {
          super(t2), this._isTransitioning = false, this._config = this._getConfig(e2), this._triggerArray = [];
          const i2 = Y.find(pt);
          for (let t3 = 0, e3 = i2.length; t3 < e3; t3++) {
            const e4 = i2[t3], s2 = o(e4), n2 = Y.find(s2).filter((t4) => t4 === this._element);
            null !== s2 && n2.length && (this._selector = s2, this._triggerArray.push(e4));
          }
          this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle();
        }
        static get Default() {
          return ct;
        }
        static get NAME() {
          return lt;
        }
        toggle() {
          this._isShown() ? this.hide() : this.show();
        }
        show() {
          if (this._isTransitioning || this._isShown())
            return;
          let t2, e2 = [];
          if (this._config.parent) {
            const t3 = Y.find(ft, this._config.parent);
            e2 = Y.find(".collapse.show, .collapse.collapsing", this._config.parent).filter((e3) => !t3.includes(e3));
          }
          const i2 = Y.findOne(this._selector);
          if (e2.length) {
            const s3 = e2.find((t3) => i2 !== t3);
            if (t2 = s3 ? mt.getInstance(s3) : null, t2 && t2._isTransitioning)
              return;
          }
          if ($.trigger(this._element, "show.bs.collapse").defaultPrevented)
            return;
          e2.forEach((e3) => {
            i2 !== e3 && mt.getOrCreateInstance(e3, { toggle: false }).hide(), t2 || z.set(e3, "bs.collapse", null);
          });
          const s2 = this._getDimension();
          this._element.classList.remove(ut), this._element.classList.add(gt), this._element.style[s2] = 0, this._addAriaAndCollapsedClass(this._triggerArray, true), this._isTransitioning = true;
          const n2 = `scroll${s2[0].toUpperCase() + s2.slice(1)}`;
          this._queueCallback(() => {
            this._isTransitioning = false, this._element.classList.remove(gt), this._element.classList.add(ut, dt), this._element.style[s2] = "", $.trigger(this._element, "shown.bs.collapse");
          }, this._element, true), this._element.style[s2] = `${this._element[n2]}px`;
        }
        hide() {
          if (this._isTransitioning || !this._isShown())
            return;
          if ($.trigger(this._element, "hide.bs.collapse").defaultPrevented)
            return;
          const t2 = this._getDimension();
          this._element.style[t2] = `${this._element.getBoundingClientRect()[t2]}px`, f(this._element), this._element.classList.add(gt), this._element.classList.remove(ut, dt);
          const e2 = this._triggerArray.length;
          for (let t3 = 0; t3 < e2; t3++) {
            const e3 = this._triggerArray[t3], i2 = r(e3);
            i2 && !this._isShown(i2) && this._addAriaAndCollapsedClass([e3], false);
          }
          this._isTransitioning = true, this._element.style[t2] = "", this._queueCallback(() => {
            this._isTransitioning = false, this._element.classList.remove(gt), this._element.classList.add(ut), $.trigger(this._element, "hidden.bs.collapse");
          }, this._element, true);
        }
        _isShown(t2 = this._element) {
          return t2.classList.contains(dt);
        }
        _getConfig(t2) {
          return (t2 = { ...ct, ...X.getDataAttributes(this._element), ...t2 }).toggle = Boolean(t2.toggle), t2.parent = c(t2.parent), h(lt, t2, ht), t2;
        }
        _getDimension() {
          return this._element.classList.contains("collapse-horizontal") ? "width" : "height";
        }
        _initializeChildren() {
          if (!this._config.parent)
            return;
          const t2 = Y.find(ft, this._config.parent);
          Y.find(pt, this._config.parent).filter((e2) => !t2.includes(e2)).forEach((t3) => {
            const e2 = r(t3);
            e2 && this._addAriaAndCollapsedClass([t3], this._isShown(e2));
          });
        }
        _addAriaAndCollapsedClass(t2, e2) {
          t2.length && t2.forEach((t3) => {
            e2 ? t3.classList.remove(_t) : t3.classList.add(_t), t3.setAttribute("aria-expanded", e2);
          });
        }
        static jQueryInterface(t2) {
          return this.each(function() {
            const e2 = {};
            "string" == typeof t2 && /show|hide/.test(t2) && (e2.toggle = false);
            const i2 = mt.getOrCreateInstance(this, e2);
            if ("string" == typeof t2) {
              if (void 0 === i2[t2])
                throw new TypeError(`No method named "${t2}"`);
              i2[t2]();
            }
          });
        }
      }
      $.on(document, "click.bs.collapse.data-api", pt, function(t2) {
        ("A" === t2.target.tagName || t2.delegateTarget && "A" === t2.delegateTarget.tagName) && t2.preventDefault();
        const e2 = o(this);
        Y.find(e2).forEach((t3) => {
          mt.getOrCreateInstance(t3, { toggle: false }).toggle();
        });
      }), v(mt);
      const bt = "dropdown", vt = "Escape", yt = "Space", Et = "ArrowUp", wt = "ArrowDown", At = new RegExp("ArrowUp|ArrowDown|Escape"), Tt = "click.bs.dropdown.data-api", Ct = "keydown.bs.dropdown.data-api", kt = "show", Lt = '[data-bs-toggle="dropdown"]', St = ".dropdown-menu", Ot = b() ? "top-end" : "top-start", Nt = b() ? "top-start" : "top-end", Dt = b() ? "bottom-end" : "bottom-start", It = b() ? "bottom-start" : "bottom-end", Pt = b() ? "left-start" : "right-start", xt = b() ? "right-start" : "left-start", Mt = { offset: [0, 2], boundary: "clippingParents", reference: "toggle", display: "dynamic", popperConfig: null, autoClose: true }, jt = { offset: "(array|string|function)", boundary: "(string|element)", reference: "(string|element|object)", display: "string", popperConfig: "(null|object|function)", autoClose: "(boolean|string)" };
      class Ht extends R {
        constructor(t2, e2) {
          super(t2), this._popper = null, this._config = this._getConfig(e2), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar();
        }
        static get Default() {
          return Mt;
        }
        static get DefaultType() {
          return jt;
        }
        static get NAME() {
          return bt;
        }
        toggle() {
          return this._isShown() ? this.hide() : this.show();
        }
        show() {
          if (u(this._element) || this._isShown(this._menu))
            return;
          const t2 = { relatedTarget: this._element };
          if ($.trigger(this._element, "show.bs.dropdown", t2).defaultPrevented)
            return;
          const e2 = Ht.getParentFromElement(this._element);
          this._inNavbar ? X.setDataAttribute(this._menu, "popper", "none") : this._createPopper(e2), "ontouchstart" in document.documentElement && !e2.closest(".navbar-nav") && [].concat(...document.body.children).forEach((t3) => $.on(t3, "mouseover", _)), this._element.focus(), this._element.setAttribute("aria-expanded", true), this._menu.classList.add(kt), this._element.classList.add(kt), $.trigger(this._element, "shown.bs.dropdown", t2);
        }
        hide() {
          if (u(this._element) || !this._isShown(this._menu))
            return;
          const t2 = { relatedTarget: this._element };
          this._completeHide(t2);
        }
        dispose() {
          this._popper && this._popper.destroy(), super.dispose();
        }
        update() {
          this._inNavbar = this._detectNavbar(), this._popper && this._popper.update();
        }
        _completeHide(t2) {
          $.trigger(this._element, "hide.bs.dropdown", t2).defaultPrevented || ("ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach((t3) => $.off(t3, "mouseover", _)), this._popper && this._popper.destroy(), this._menu.classList.remove(kt), this._element.classList.remove(kt), this._element.setAttribute("aria-expanded", "false"), X.removeDataAttribute(this._menu, "popper"), $.trigger(this._element, "hidden.bs.dropdown", t2));
        }
        _getConfig(t2) {
          if (t2 = { ...this.constructor.Default, ...X.getDataAttributes(this._element), ...t2 }, h(bt, t2, this.constructor.DefaultType), "object" == typeof t2.reference && !l(t2.reference) && "function" != typeof t2.reference.getBoundingClientRect)
            throw new TypeError(`${bt.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
          return t2;
        }
        _createPopper(t2) {
          if (void 0 === i)
            throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
          let e2 = this._element;
          "parent" === this._config.reference ? e2 = t2 : l(this._config.reference) ? e2 = c(this._config.reference) : "object" == typeof this._config.reference && (e2 = this._config.reference);
          const s2 = this._getPopperConfig(), n2 = s2.modifiers.find((t3) => "applyStyles" === t3.name && false === t3.enabled);
          this._popper = i.createPopper(e2, this._menu, s2), n2 && X.setDataAttribute(this._menu, "popper", "static");
        }
        _isShown(t2 = this._element) {
          return t2.classList.contains(kt);
        }
        _getMenuElement() {
          return Y.next(this._element, St)[0];
        }
        _getPlacement() {
          const t2 = this._element.parentNode;
          if (t2.classList.contains("dropend"))
            return Pt;
          if (t2.classList.contains("dropstart"))
            return xt;
          const e2 = "end" === getComputedStyle(this._menu).getPropertyValue("--bs-position").trim();
          return t2.classList.contains("dropup") ? e2 ? Nt : Ot : e2 ? It : Dt;
        }
        _detectNavbar() {
          return null !== this._element.closest(".navbar");
        }
        _getOffset() {
          const { offset: t2 } = this._config;
          return "string" == typeof t2 ? t2.split(",").map((t3) => Number.parseInt(t3, 10)) : "function" == typeof t2 ? (e2) => t2(e2, this._element) : t2;
        }
        _getPopperConfig() {
          const t2 = { placement: this._getPlacement(), modifiers: [{ name: "preventOverflow", options: { boundary: this._config.boundary } }, { name: "offset", options: { offset: this._getOffset() } }] };
          return "static" === this._config.display && (t2.modifiers = [{ name: "applyStyles", enabled: false }]), { ...t2, ..."function" == typeof this._config.popperConfig ? this._config.popperConfig(t2) : this._config.popperConfig };
        }
        _selectMenuItem({ key: t2, target: e2 }) {
          const i2 = Y.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", this._menu).filter(d);
          i2.length && w(i2, e2, t2 === wt, !i2.includes(e2)).focus();
        }
        static jQueryInterface(t2) {
          return this.each(function() {
            const e2 = Ht.getOrCreateInstance(this, t2);
            if ("string" == typeof t2) {
              if (void 0 === e2[t2])
                throw new TypeError(`No method named "${t2}"`);
              e2[t2]();
            }
          });
        }
        static clearMenus(t2) {
          if (t2 && (2 === t2.button || "keyup" === t2.type && "Tab" !== t2.key))
            return;
          const e2 = Y.find(Lt);
          for (let i2 = 0, s2 = e2.length; i2 < s2; i2++) {
            const s3 = Ht.getInstance(e2[i2]);
            if (!s3 || false === s3._config.autoClose)
              continue;
            if (!s3._isShown())
              continue;
            const n2 = { relatedTarget: s3._element };
            if (t2) {
              const e3 = t2.composedPath(), i3 = e3.includes(s3._menu);
              if (e3.includes(s3._element) || "inside" === s3._config.autoClose && !i3 || "outside" === s3._config.autoClose && i3)
                continue;
              if (s3._menu.contains(t2.target) && ("keyup" === t2.type && "Tab" === t2.key || /input|select|option|textarea|form/i.test(t2.target.tagName)))
                continue;
              "click" === t2.type && (n2.clickEvent = t2);
            }
            s3._completeHide(n2);
          }
        }
        static getParentFromElement(t2) {
          return r(t2) || t2.parentNode;
        }
        static dataApiKeydownHandler(t2) {
          if (/input|textarea/i.test(t2.target.tagName) ? t2.key === yt || t2.key !== vt && (t2.key !== wt && t2.key !== Et || t2.target.closest(St)) : !At.test(t2.key))
            return;
          const e2 = this.classList.contains(kt);
          if (!e2 && t2.key === vt)
            return;
          if (t2.preventDefault(), t2.stopPropagation(), u(this))
            return;
          const i2 = this.matches(Lt) ? this : Y.prev(this, Lt)[0], s2 = Ht.getOrCreateInstance(i2);
          if (t2.key !== vt)
            return t2.key === Et || t2.key === wt ? (e2 || s2.show(), void s2._selectMenuItem(t2)) : void (e2 && t2.key !== yt || Ht.clearMenus());
          s2.hide();
        }
      }
      $.on(document, Ct, Lt, Ht.dataApiKeydownHandler), $.on(document, Ct, St, Ht.dataApiKeydownHandler), $.on(document, Tt, Ht.clearMenus), $.on(document, "keyup.bs.dropdown.data-api", Ht.clearMenus), $.on(document, Tt, Lt, function(t2) {
        t2.preventDefault(), Ht.getOrCreateInstance(this).toggle();
      }), v(Ht);
      const $t = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", Bt = ".sticky-top";
      class zt {
        constructor() {
          this._element = document.body;
        }
        getWidth() {
          const t2 = document.documentElement.clientWidth;
          return Math.abs(window.innerWidth - t2);
        }
        hide() {
          const t2 = this.getWidth();
          this._disableOverFlow(), this._setElementAttributes(this._element, "paddingRight", (e2) => e2 + t2), this._setElementAttributes($t, "paddingRight", (e2) => e2 + t2), this._setElementAttributes(Bt, "marginRight", (e2) => e2 - t2);
        }
        _disableOverFlow() {
          this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden";
        }
        _setElementAttributes(t2, e2, i2) {
          const s2 = this.getWidth();
          this._applyManipulationCallback(t2, (t3) => {
            if (t3 !== this._element && window.innerWidth > t3.clientWidth + s2)
              return;
            this._saveInitialAttribute(t3, e2);
            const n2 = window.getComputedStyle(t3)[e2];
            t3.style[e2] = `${i2(Number.parseFloat(n2))}px`;
          });
        }
        reset() {
          this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, "paddingRight"), this._resetElementAttributes($t, "paddingRight"), this._resetElementAttributes(Bt, "marginRight");
        }
        _saveInitialAttribute(t2, e2) {
          const i2 = t2.style[e2];
          i2 && X.setDataAttribute(t2, e2, i2);
        }
        _resetElementAttributes(t2, e2) {
          this._applyManipulationCallback(t2, (t3) => {
            const i2 = X.getDataAttribute(t3, e2);
            void 0 === i2 ? t3.style.removeProperty(e2) : (X.removeDataAttribute(t3, e2), t3.style[e2] = i2);
          });
        }
        _applyManipulationCallback(t2, e2) {
          l(t2) ? e2(t2) : Y.find(t2, this._element).forEach(e2);
        }
        isOverflowing() {
          return this.getWidth() > 0;
        }
      }
      const Rt = { className: "modal-backdrop", isVisible: true, isAnimated: false, rootElement: "body", clickCallback: null }, Ft = { className: "string", isVisible: "boolean", isAnimated: "boolean", rootElement: "(element|string)", clickCallback: "(function|null)" }, qt = "show", Wt = "mousedown.bs.backdrop";
      class Ut {
        constructor(t2) {
          this._config = this._getConfig(t2), this._isAppended = false, this._element = null;
        }
        show(t2) {
          this._config.isVisible ? (this._append(), this._config.isAnimated && f(this._getElement()), this._getElement().classList.add(qt), this._emulateAnimation(() => {
            y(t2);
          })) : y(t2);
        }
        hide(t2) {
          this._config.isVisible ? (this._getElement().classList.remove(qt), this._emulateAnimation(() => {
            this.dispose(), y(t2);
          })) : y(t2);
        }
        _getElement() {
          if (!this._element) {
            const t2 = document.createElement("div");
            t2.className = this._config.className, this._config.isAnimated && t2.classList.add("fade"), this._element = t2;
          }
          return this._element;
        }
        _getConfig(t2) {
          return (t2 = { ...Rt, ..."object" == typeof t2 ? t2 : {} }).rootElement = c(t2.rootElement), h("backdrop", t2, Ft), t2;
        }
        _append() {
          this._isAppended || (this._config.rootElement.append(this._getElement()), $.on(this._getElement(), Wt, () => {
            y(this._config.clickCallback);
          }), this._isAppended = true);
        }
        dispose() {
          this._isAppended && ($.off(this._element, Wt), this._element.remove(), this._isAppended = false);
        }
        _emulateAnimation(t2) {
          E(t2, this._getElement(), this._config.isAnimated);
        }
      }
      const Kt = { trapElement: null, autofocus: true }, Vt = { trapElement: "element", autofocus: "boolean" }, Xt = ".bs.focustrap", Yt = "backward";
      class Qt {
        constructor(t2) {
          this._config = this._getConfig(t2), this._isActive = false, this._lastTabNavDirection = null;
        }
        activate() {
          const { trapElement: t2, autofocus: e2 } = this._config;
          this._isActive || (e2 && t2.focus(), $.off(document, Xt), $.on(document, "focusin.bs.focustrap", (t3) => this._handleFocusin(t3)), $.on(document, "keydown.tab.bs.focustrap", (t3) => this._handleKeydown(t3)), this._isActive = true);
        }
        deactivate() {
          this._isActive && (this._isActive = false, $.off(document, Xt));
        }
        _handleFocusin(t2) {
          const { target: e2 } = t2, { trapElement: i2 } = this._config;
          if (e2 === document || e2 === i2 || i2.contains(e2))
            return;
          const s2 = Y.focusableChildren(i2);
          0 === s2.length ? i2.focus() : this._lastTabNavDirection === Yt ? s2[s2.length - 1].focus() : s2[0].focus();
        }
        _handleKeydown(t2) {
          "Tab" === t2.key && (this._lastTabNavDirection = t2.shiftKey ? Yt : "forward");
        }
        _getConfig(t2) {
          return t2 = { ...Kt, ..."object" == typeof t2 ? t2 : {} }, h("focustrap", t2, Vt), t2;
        }
      }
      const Gt = "modal", Zt = "Escape", Jt = { backdrop: true, keyboard: true, focus: true }, te = { backdrop: "(boolean|string)", keyboard: "boolean", focus: "boolean" }, ee = "hidden.bs.modal", ie = "show.bs.modal", se = "resize.bs.modal", ne = "click.dismiss.bs.modal", oe = "keydown.dismiss.bs.modal", re = "mousedown.dismiss.bs.modal", ae = "modal-open", le = "show", ce = "modal-static";
      class he extends R {
        constructor(t2, e2) {
          super(t2), this._config = this._getConfig(e2), this._dialog = Y.findOne(".modal-dialog", this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = false, this._ignoreBackdropClick = false, this._isTransitioning = false, this._scrollBar = new zt();
        }
        static get Default() {
          return Jt;
        }
        static get NAME() {
          return Gt;
        }
        toggle(t2) {
          return this._isShown ? this.hide() : this.show(t2);
        }
        show(t2) {
          this._isShown || this._isTransitioning || $.trigger(this._element, ie, { relatedTarget: t2 }).defaultPrevented || (this._isShown = true, this._isAnimated() && (this._isTransitioning = true), this._scrollBar.hide(), document.body.classList.add(ae), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), $.on(this._dialog, re, () => {
            $.one(this._element, "mouseup.dismiss.bs.modal", (t3) => {
              t3.target === this._element && (this._ignoreBackdropClick = true);
            });
          }), this._showBackdrop(() => this._showElement(t2)));
        }
        hide() {
          if (!this._isShown || this._isTransitioning)
            return;
          if ($.trigger(this._element, "hide.bs.modal").defaultPrevented)
            return;
          this._isShown = false;
          const t2 = this._isAnimated();
          t2 && (this._isTransitioning = true), this._setEscapeEvent(), this._setResizeEvent(), this._focustrap.deactivate(), this._element.classList.remove(le), $.off(this._element, ne), $.off(this._dialog, re), this._queueCallback(() => this._hideModal(), this._element, t2);
        }
        dispose() {
          [window, this._dialog].forEach((t2) => $.off(t2, ".bs.modal")), this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();
        }
        handleUpdate() {
          this._adjustDialog();
        }
        _initializeBackDrop() {
          return new Ut({ isVisible: Boolean(this._config.backdrop), isAnimated: this._isAnimated() });
        }
        _initializeFocusTrap() {
          return new Qt({ trapElement: this._element });
        }
        _getConfig(t2) {
          return t2 = { ...Jt, ...X.getDataAttributes(this._element), ..."object" == typeof t2 ? t2 : {} }, h(Gt, t2, te), t2;
        }
        _showElement(t2) {
          const e2 = this._isAnimated(), i2 = Y.findOne(".modal-body", this._dialog);
          this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE || document.body.append(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", true), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0, i2 && (i2.scrollTop = 0), e2 && f(this._element), this._element.classList.add(le), this._queueCallback(() => {
            this._config.focus && this._focustrap.activate(), this._isTransitioning = false, $.trigger(this._element, "shown.bs.modal", { relatedTarget: t2 });
          }, this._dialog, e2);
        }
        _setEscapeEvent() {
          this._isShown ? $.on(this._element, oe, (t2) => {
            this._config.keyboard && t2.key === Zt ? (t2.preventDefault(), this.hide()) : this._config.keyboard || t2.key !== Zt || this._triggerBackdropTransition();
          }) : $.off(this._element, oe);
        }
        _setResizeEvent() {
          this._isShown ? $.on(window, se, () => this._adjustDialog()) : $.off(window, se);
        }
        _hideModal() {
          this._element.style.display = "none", this._element.setAttribute("aria-hidden", true), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = false, this._backdrop.hide(() => {
            document.body.classList.remove(ae), this._resetAdjustments(), this._scrollBar.reset(), $.trigger(this._element, ee);
          });
        }
        _showBackdrop(t2) {
          $.on(this._element, ne, (t3) => {
            this._ignoreBackdropClick ? this._ignoreBackdropClick = false : t3.target === t3.currentTarget && (true === this._config.backdrop ? this.hide() : "static" === this._config.backdrop && this._triggerBackdropTransition());
          }), this._backdrop.show(t2);
        }
        _isAnimated() {
          return this._element.classList.contains("fade");
        }
        _triggerBackdropTransition() {
          if ($.trigger(this._element, "hidePrevented.bs.modal").defaultPrevented)
            return;
          const { classList: t2, scrollHeight: e2, style: i2 } = this._element, s2 = e2 > document.documentElement.clientHeight;
          !s2 && "hidden" === i2.overflowY || t2.contains(ce) || (s2 || (i2.overflowY = "hidden"), t2.add(ce), this._queueCallback(() => {
            t2.remove(ce), s2 || this._queueCallback(() => {
              i2.overflowY = "";
            }, this._dialog);
          }, this._dialog), this._element.focus());
        }
        _adjustDialog() {
          const t2 = this._element.scrollHeight > document.documentElement.clientHeight, e2 = this._scrollBar.getWidth(), i2 = e2 > 0;
          (!i2 && t2 && !b() || i2 && !t2 && b()) && (this._element.style.paddingLeft = `${e2}px`), (i2 && !t2 && !b() || !i2 && t2 && b()) && (this._element.style.paddingRight = `${e2}px`);
        }
        _resetAdjustments() {
          this._element.style.paddingLeft = "", this._element.style.paddingRight = "";
        }
        static jQueryInterface(t2, e2) {
          return this.each(function() {
            const i2 = he.getOrCreateInstance(this, t2);
            if ("string" == typeof t2) {
              if (void 0 === i2[t2])
                throw new TypeError(`No method named "${t2}"`);
              i2[t2](e2);
            }
          });
        }
      }
      $.on(document, "click.bs.modal.data-api", '[data-bs-toggle="modal"]', function(t2) {
        const e2 = r(this);
        ["A", "AREA"].includes(this.tagName) && t2.preventDefault(), $.one(e2, ie, (t3) => {
          t3.defaultPrevented || $.one(e2, ee, () => {
            d(this) && this.focus();
          });
        });
        const i2 = Y.findOne(".modal.show");
        i2 && he.getInstance(i2).hide(), he.getOrCreateInstance(e2).toggle(this);
      }), F(he), v(he);
      const de = "offcanvas", ue = { backdrop: true, keyboard: true, scroll: false }, ge = { backdrop: "boolean", keyboard: "boolean", scroll: "boolean" }, _e = "show", fe = ".offcanvas.show", pe = "hidden.bs.offcanvas";
      class me extends R {
        constructor(t2, e2) {
          super(t2), this._config = this._getConfig(e2), this._isShown = false, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners();
        }
        static get NAME() {
          return de;
        }
        static get Default() {
          return ue;
        }
        toggle(t2) {
          return this._isShown ? this.hide() : this.show(t2);
        }
        show(t2) {
          this._isShown || $.trigger(this._element, "show.bs.offcanvas", { relatedTarget: t2 }).defaultPrevented || (this._isShown = true, this._element.style.visibility = "visible", this._backdrop.show(), this._config.scroll || new zt().hide(), this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", true), this._element.setAttribute("role", "dialog"), this._element.classList.add(_e), this._queueCallback(() => {
            this._config.scroll || this._focustrap.activate(), $.trigger(this._element, "shown.bs.offcanvas", { relatedTarget: t2 });
          }, this._element, true));
        }
        hide() {
          this._isShown && ($.trigger(this._element, "hide.bs.offcanvas").defaultPrevented || (this._focustrap.deactivate(), this._element.blur(), this._isShown = false, this._element.classList.remove(_e), this._backdrop.hide(), this._queueCallback(() => {
            this._element.setAttribute("aria-hidden", true), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._element.style.visibility = "hidden", this._config.scroll || new zt().reset(), $.trigger(this._element, pe);
          }, this._element, true)));
        }
        dispose() {
          this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();
        }
        _getConfig(t2) {
          return t2 = { ...ue, ...X.getDataAttributes(this._element), ..."object" == typeof t2 ? t2 : {} }, h(de, t2, ge), t2;
        }
        _initializeBackDrop() {
          return new Ut({ className: "offcanvas-backdrop", isVisible: this._config.backdrop, isAnimated: true, rootElement: this._element.parentNode, clickCallback: () => this.hide() });
        }
        _initializeFocusTrap() {
          return new Qt({ trapElement: this._element });
        }
        _addEventListeners() {
          $.on(this._element, "keydown.dismiss.bs.offcanvas", (t2) => {
            this._config.keyboard && "Escape" === t2.key && this.hide();
          });
        }
        static jQueryInterface(t2) {
          return this.each(function() {
            const e2 = me.getOrCreateInstance(this, t2);
            if ("string" == typeof t2) {
              if (void 0 === e2[t2] || t2.startsWith("_") || "constructor" === t2)
                throw new TypeError(`No method named "${t2}"`);
              e2[t2](this);
            }
          });
        }
      }
      $.on(document, "click.bs.offcanvas.data-api", '[data-bs-toggle="offcanvas"]', function(t2) {
        const e2 = r(this);
        if (["A", "AREA"].includes(this.tagName) && t2.preventDefault(), u(this))
          return;
        $.one(e2, pe, () => {
          d(this) && this.focus();
        });
        const i2 = Y.findOne(fe);
        i2 && i2 !== e2 && me.getInstance(i2).hide(), me.getOrCreateInstance(e2).toggle(this);
      }), $.on(window, "load.bs.offcanvas.data-api", () => Y.find(fe).forEach((t2) => me.getOrCreateInstance(t2).show())), F(me), v(me);
      const be = /* @__PURE__ */ new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]), ve = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i, ye = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i, Ee = (t2, e2) => {
        const i2 = t2.nodeName.toLowerCase();
        if (e2.includes(i2))
          return !be.has(i2) || Boolean(ve.test(t2.nodeValue) || ye.test(t2.nodeValue));
        const s2 = e2.filter((t3) => t3 instanceof RegExp);
        for (let t3 = 0, e3 = s2.length; t3 < e3; t3++)
          if (s2[t3].test(i2))
            return true;
        return false;
      };
      function we(t2, e2, i2) {
        if (!t2.length)
          return t2;
        if (i2 && "function" == typeof i2)
          return i2(t2);
        const s2 = new window.DOMParser().parseFromString(t2, "text/html"), n2 = [].concat(...s2.body.querySelectorAll("*"));
        for (let t3 = 0, i3 = n2.length; t3 < i3; t3++) {
          const i4 = n2[t3], s3 = i4.nodeName.toLowerCase();
          if (!Object.keys(e2).includes(s3)) {
            i4.remove();
            continue;
          }
          const o2 = [].concat(...i4.attributes), r2 = [].concat(e2["*"] || [], e2[s3] || []);
          o2.forEach((t4) => {
            Ee(t4, r2) || i4.removeAttribute(t4.nodeName);
          });
        }
        return s2.body.innerHTML;
      }
      const Ae = "tooltip", Te = /* @__PURE__ */ new Set(["sanitize", "allowList", "sanitizeFn"]), Ce = { animation: "boolean", template: "string", title: "(string|element|function)", trigger: "string", delay: "(number|object)", html: "boolean", selector: "(string|boolean)", placement: "(string|function)", offset: "(array|string|function)", container: "(string|element|boolean)", fallbackPlacements: "array", boundary: "(string|element)", customClass: "(string|function)", sanitize: "boolean", sanitizeFn: "(null|function)", allowList: "object", popperConfig: "(null|object|function)" }, ke = { AUTO: "auto", TOP: "top", RIGHT: b() ? "left" : "right", BOTTOM: "bottom", LEFT: b() ? "right" : "left" }, Le = { animation: true, template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>', trigger: "hover focus", title: "", delay: 0, html: false, selector: false, placement: "top", offset: [0, 0], container: false, fallbackPlacements: ["top", "right", "bottom", "left"], boundary: "clippingParents", customClass: "", sanitize: true, sanitizeFn: null, allowList: { "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i], a: ["target", "href", "title", "rel"], area: [], b: [], br: [], col: [], code: [], div: [], em: [], hr: [], h1: [], h2: [], h3: [], h4: [], h5: [], h6: [], i: [], img: ["src", "srcset", "alt", "title", "width", "height"], li: [], ol: [], p: [], pre: [], s: [], small: [], span: [], sub: [], sup: [], strong: [], u: [], ul: [] }, popperConfig: null }, Se = { HIDE: "hide.bs.tooltip", HIDDEN: "hidden.bs.tooltip", SHOW: "show.bs.tooltip", SHOWN: "shown.bs.tooltip", INSERTED: "inserted.bs.tooltip", CLICK: "click.bs.tooltip", FOCUSIN: "focusin.bs.tooltip", FOCUSOUT: "focusout.bs.tooltip", MOUSEENTER: "mouseenter.bs.tooltip", MOUSELEAVE: "mouseleave.bs.tooltip" }, Oe = "fade", Ne = "show", De = "show", Ie = "out", Pe = ".tooltip-inner", xe = ".modal", Me = "hide.bs.modal", je = "hover", He = "focus";
      class $e extends R {
        constructor(t2, e2) {
          if (void 0 === i)
            throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
          super(t2), this._isEnabled = true, this._timeout = 0, this._hoverState = "", this._activeTrigger = {}, this._popper = null, this._config = this._getConfig(e2), this.tip = null, this._setListeners();
        }
        static get Default() {
          return Le;
        }
        static get NAME() {
          return Ae;
        }
        static get Event() {
          return Se;
        }
        static get DefaultType() {
          return Ce;
        }
        enable() {
          this._isEnabled = true;
        }
        disable() {
          this._isEnabled = false;
        }
        toggleEnabled() {
          this._isEnabled = !this._isEnabled;
        }
        toggle(t2) {
          if (this._isEnabled)
            if (t2) {
              const e2 = this._initializeOnDelegatedTarget(t2);
              e2._activeTrigger.click = !e2._activeTrigger.click, e2._isWithActiveTrigger() ? e2._enter(null, e2) : e2._leave(null, e2);
            } else {
              if (this.getTipElement().classList.contains(Ne))
                return void this._leave(null, this);
              this._enter(null, this);
            }
        }
        dispose() {
          clearTimeout(this._timeout), $.off(this._element.closest(xe), Me, this._hideModalHandler), this.tip && this.tip.remove(), this._disposePopper(), super.dispose();
        }
        show() {
          if ("none" === this._element.style.display)
            throw new Error("Please use show on visible elements");
          if (!this.isWithContent() || !this._isEnabled)
            return;
          const t2 = $.trigger(this._element, this.constructor.Event.SHOW), e2 = g(this._element), s2 = null === e2 ? this._element.ownerDocument.documentElement.contains(this._element) : e2.contains(this._element);
          if (t2.defaultPrevented || !s2)
            return;
          "tooltip" === this.constructor.NAME && this.tip && this.getTitle() !== this.tip.querySelector(Pe).innerHTML && (this._disposePopper(), this.tip.remove(), this.tip = null);
          const n2 = this.getTipElement(), o2 = ((t3) => {
            do {
              t3 += Math.floor(1e6 * Math.random());
            } while (document.getElementById(t3));
            return t3;
          })(this.constructor.NAME);
          n2.setAttribute("id", o2), this._element.setAttribute("aria-describedby", o2), this._config.animation && n2.classList.add(Oe);
          const r2 = "function" == typeof this._config.placement ? this._config.placement.call(this, n2, this._element) : this._config.placement, a2 = this._getAttachment(r2);
          this._addAttachmentClass(a2);
          const { container: l2 } = this._config;
          z.set(n2, this.constructor.DATA_KEY, this), this._element.ownerDocument.documentElement.contains(this.tip) || (l2.append(n2), $.trigger(this._element, this.constructor.Event.INSERTED)), this._popper ? this._popper.update() : this._popper = i.createPopper(this._element, n2, this._getPopperConfig(a2)), n2.classList.add(Ne);
          const c2 = this._resolvePossibleFunction(this._config.customClass);
          c2 && n2.classList.add(...c2.split(" ")), "ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach((t3) => {
            $.on(t3, "mouseover", _);
          });
          const h2 = this.tip.classList.contains(Oe);
          this._queueCallback(() => {
            const t3 = this._hoverState;
            this._hoverState = null, $.trigger(this._element, this.constructor.Event.SHOWN), t3 === Ie && this._leave(null, this);
          }, this.tip, h2);
        }
        hide() {
          if (!this._popper)
            return;
          const t2 = this.getTipElement();
          if ($.trigger(this._element, this.constructor.Event.HIDE).defaultPrevented)
            return;
          t2.classList.remove(Ne), "ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach((t3) => $.off(t3, "mouseover", _)), this._activeTrigger.click = false, this._activeTrigger.focus = false, this._activeTrigger.hover = false;
          const e2 = this.tip.classList.contains(Oe);
          this._queueCallback(() => {
            this._isWithActiveTrigger() || (this._hoverState !== De && t2.remove(), this._cleanTipClass(), this._element.removeAttribute("aria-describedby"), $.trigger(this._element, this.constructor.Event.HIDDEN), this._disposePopper());
          }, this.tip, e2), this._hoverState = "";
        }
        update() {
          null !== this._popper && this._popper.update();
        }
        isWithContent() {
          return Boolean(this.getTitle());
        }
        getTipElement() {
          if (this.tip)
            return this.tip;
          const t2 = document.createElement("div");
          t2.innerHTML = this._config.template;
          const e2 = t2.children[0];
          return this.setContent(e2), e2.classList.remove(Oe, Ne), this.tip = e2, this.tip;
        }
        setContent(t2) {
          this._sanitizeAndSetContent(t2, this.getTitle(), Pe);
        }
        _sanitizeAndSetContent(t2, e2, i2) {
          const s2 = Y.findOne(i2, t2);
          e2 || !s2 ? this.setElementContent(s2, e2) : s2.remove();
        }
        setElementContent(t2, e2) {
          if (null !== t2)
            return l(e2) ? (e2 = c(e2), void (this._config.html ? e2.parentNode !== t2 && (t2.innerHTML = "", t2.append(e2)) : t2.textContent = e2.textContent)) : void (this._config.html ? (this._config.sanitize && (e2 = we(e2, this._config.allowList, this._config.sanitizeFn)), t2.innerHTML = e2) : t2.textContent = e2);
        }
        getTitle() {
          const t2 = this._element.getAttribute("data-bs-original-title") || this._config.title;
          return this._resolvePossibleFunction(t2);
        }
        updateAttachment(t2) {
          return "right" === t2 ? "end" : "left" === t2 ? "start" : t2;
        }
        _initializeOnDelegatedTarget(t2, e2) {
          return e2 || this.constructor.getOrCreateInstance(t2.delegateTarget, this._getDelegateConfig());
        }
        _getOffset() {
          const { offset: t2 } = this._config;
          return "string" == typeof t2 ? t2.split(",").map((t3) => Number.parseInt(t3, 10)) : "function" == typeof t2 ? (e2) => t2(e2, this._element) : t2;
        }
        _resolvePossibleFunction(t2) {
          return "function" == typeof t2 ? t2.call(this._element) : t2;
        }
        _getPopperConfig(t2) {
          const e2 = { placement: t2, modifiers: [{ name: "flip", options: { fallbackPlacements: this._config.fallbackPlacements } }, { name: "offset", options: { offset: this._getOffset() } }, { name: "preventOverflow", options: { boundary: this._config.boundary } }, { name: "arrow", options: { element: `.${this.constructor.NAME}-arrow` } }, { name: "onChange", enabled: true, phase: "afterWrite", fn: (t3) => this._handlePopperPlacementChange(t3) }], onFirstUpdate: (t3) => {
            t3.options.placement !== t3.placement && this._handlePopperPlacementChange(t3);
          } };
          return { ...e2, ..."function" == typeof this._config.popperConfig ? this._config.popperConfig(e2) : this._config.popperConfig };
        }
        _addAttachmentClass(t2) {
          this.getTipElement().classList.add(`${this._getBasicClassPrefix()}-${this.updateAttachment(t2)}`);
        }
        _getAttachment(t2) {
          return ke[t2.toUpperCase()];
        }
        _setListeners() {
          this._config.trigger.split(" ").forEach((t2) => {
            if ("click" === t2)
              $.on(this._element, this.constructor.Event.CLICK, this._config.selector, (t3) => this.toggle(t3));
            else if ("manual" !== t2) {
              const e2 = t2 === je ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN, i2 = t2 === je ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT;
              $.on(this._element, e2, this._config.selector, (t3) => this._enter(t3)), $.on(this._element, i2, this._config.selector, (t3) => this._leave(t3));
            }
          }), this._hideModalHandler = () => {
            this._element && this.hide();
          }, $.on(this._element.closest(xe), Me, this._hideModalHandler), this._config.selector ? this._config = { ...this._config, trigger: "manual", selector: "" } : this._fixTitle();
        }
        _fixTitle() {
          const t2 = this._element.getAttribute("title"), e2 = typeof this._element.getAttribute("data-bs-original-title");
          (t2 || "string" !== e2) && (this._element.setAttribute("data-bs-original-title", t2 || ""), !t2 || this._element.getAttribute("aria-label") || this._element.textContent || this._element.setAttribute("aria-label", t2), this._element.setAttribute("title", ""));
        }
        _enter(t2, e2) {
          e2 = this._initializeOnDelegatedTarget(t2, e2), t2 && (e2._activeTrigger["focusin" === t2.type ? He : je] = true), e2.getTipElement().classList.contains(Ne) || e2._hoverState === De ? e2._hoverState = De : (clearTimeout(e2._timeout), e2._hoverState = De, e2._config.delay && e2._config.delay.show ? e2._timeout = setTimeout(() => {
            e2._hoverState === De && e2.show();
          }, e2._config.delay.show) : e2.show());
        }
        _leave(t2, e2) {
          e2 = this._initializeOnDelegatedTarget(t2, e2), t2 && (e2._activeTrigger["focusout" === t2.type ? He : je] = e2._element.contains(t2.relatedTarget)), e2._isWithActiveTrigger() || (clearTimeout(e2._timeout), e2._hoverState = Ie, e2._config.delay && e2._config.delay.hide ? e2._timeout = setTimeout(() => {
            e2._hoverState === Ie && e2.hide();
          }, e2._config.delay.hide) : e2.hide());
        }
        _isWithActiveTrigger() {
          for (const t2 in this._activeTrigger)
            if (this._activeTrigger[t2])
              return true;
          return false;
        }
        _getConfig(t2) {
          const e2 = X.getDataAttributes(this._element);
          return Object.keys(e2).forEach((t3) => {
            Te.has(t3) && delete e2[t3];
          }), (t2 = { ...this.constructor.Default, ...e2, ..."object" == typeof t2 && t2 ? t2 : {} }).container = false === t2.container ? document.body : c(t2.container), "number" == typeof t2.delay && (t2.delay = { show: t2.delay, hide: t2.delay }), "number" == typeof t2.title && (t2.title = t2.title.toString()), "number" == typeof t2.content && (t2.content = t2.content.toString()), h(Ae, t2, this.constructor.DefaultType), t2.sanitize && (t2.template = we(t2.template, t2.allowList, t2.sanitizeFn)), t2;
        }
        _getDelegateConfig() {
          const t2 = {};
          for (const e2 in this._config)
            this.constructor.Default[e2] !== this._config[e2] && (t2[e2] = this._config[e2]);
          return t2;
        }
        _cleanTipClass() {
          const t2 = this.getTipElement(), e2 = new RegExp(`(^|\\s)${this._getBasicClassPrefix()}\\S+`, "g"), i2 = t2.getAttribute("class").match(e2);
          null !== i2 && i2.length > 0 && i2.map((t3) => t3.trim()).forEach((e3) => t2.classList.remove(e3));
        }
        _getBasicClassPrefix() {
          return "bs-tooltip";
        }
        _handlePopperPlacementChange(t2) {
          const { state: e2 } = t2;
          e2 && (this.tip = e2.elements.popper, this._cleanTipClass(), this._addAttachmentClass(this._getAttachment(e2.placement)));
        }
        _disposePopper() {
          this._popper && (this._popper.destroy(), this._popper = null);
        }
        static jQueryInterface(t2) {
          return this.each(function() {
            const e2 = $e.getOrCreateInstance(this, t2);
            if ("string" == typeof t2) {
              if (void 0 === e2[t2])
                throw new TypeError(`No method named "${t2}"`);
              e2[t2]();
            }
          });
        }
      }
      v($e);
      const Be = { ...$e.Default, placement: "right", offset: [0, 8], trigger: "click", content: "", template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>' }, ze = { ...$e.DefaultType, content: "(string|element|function)" }, Re = { HIDE: "hide.bs.popover", HIDDEN: "hidden.bs.popover", SHOW: "show.bs.popover", SHOWN: "shown.bs.popover", INSERTED: "inserted.bs.popover", CLICK: "click.bs.popover", FOCUSIN: "focusin.bs.popover", FOCUSOUT: "focusout.bs.popover", MOUSEENTER: "mouseenter.bs.popover", MOUSELEAVE: "mouseleave.bs.popover" };
      class Fe extends $e {
        static get Default() {
          return Be;
        }
        static get NAME() {
          return "popover";
        }
        static get Event() {
          return Re;
        }
        static get DefaultType() {
          return ze;
        }
        isWithContent() {
          return this.getTitle() || this._getContent();
        }
        setContent(t2) {
          this._sanitizeAndSetContent(t2, this.getTitle(), ".popover-header"), this._sanitizeAndSetContent(t2, this._getContent(), ".popover-body");
        }
        _getContent() {
          return this._resolvePossibleFunction(this._config.content);
        }
        _getBasicClassPrefix() {
          return "bs-popover";
        }
        static jQueryInterface(t2) {
          return this.each(function() {
            const e2 = Fe.getOrCreateInstance(this, t2);
            if ("string" == typeof t2) {
              if (void 0 === e2[t2])
                throw new TypeError(`No method named "${t2}"`);
              e2[t2]();
            }
          });
        }
      }
      v(Fe);
      const qe = "scrollspy", We = { offset: 10, method: "auto", target: "" }, Ue = { offset: "number", method: "string", target: "(string|element)" }, Ke = "active", Ve = ".nav-link, .list-group-item, .dropdown-item", Xe = "position";
      class Ye extends R {
        constructor(t2, e2) {
          super(t2), this._scrollElement = "BODY" === this._element.tagName ? window : this._element, this._config = this._getConfig(e2), this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, $.on(this._scrollElement, "scroll.bs.scrollspy", () => this._process()), this.refresh(), this._process();
        }
        static get Default() {
          return We;
        }
        static get NAME() {
          return qe;
        }
        refresh() {
          const t2 = this._scrollElement === this._scrollElement.window ? "offset" : Xe, e2 = "auto" === this._config.method ? t2 : this._config.method, i2 = e2 === Xe ? this._getScrollTop() : 0;
          this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), Y.find(Ve, this._config.target).map((t3) => {
            const s2 = o(t3), n2 = s2 ? Y.findOne(s2) : null;
            if (n2) {
              const t4 = n2.getBoundingClientRect();
              if (t4.width || t4.height)
                return [X[e2](n2).top + i2, s2];
            }
            return null;
          }).filter((t3) => t3).sort((t3, e3) => t3[0] - e3[0]).forEach((t3) => {
            this._offsets.push(t3[0]), this._targets.push(t3[1]);
          });
        }
        dispose() {
          $.off(this._scrollElement, ".bs.scrollspy"), super.dispose();
        }
        _getConfig(t2) {
          return (t2 = { ...We, ...X.getDataAttributes(this._element), ..."object" == typeof t2 && t2 ? t2 : {} }).target = c(t2.target) || document.documentElement, h(qe, t2, Ue), t2;
        }
        _getScrollTop() {
          return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
        }
        _getScrollHeight() {
          return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
        }
        _getOffsetHeight() {
          return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
        }
        _process() {
          const t2 = this._getScrollTop() + this._config.offset, e2 = this._getScrollHeight(), i2 = this._config.offset + e2 - this._getOffsetHeight();
          if (this._scrollHeight !== e2 && this.refresh(), t2 >= i2) {
            const t3 = this._targets[this._targets.length - 1];
            this._activeTarget !== t3 && this._activate(t3);
          } else {
            if (this._activeTarget && t2 < this._offsets[0] && this._offsets[0] > 0)
              return this._activeTarget = null, void this._clear();
            for (let e3 = this._offsets.length; e3--; )
              this._activeTarget !== this._targets[e3] && t2 >= this._offsets[e3] && (void 0 === this._offsets[e3 + 1] || t2 < this._offsets[e3 + 1]) && this._activate(this._targets[e3]);
          }
        }
        _activate(t2) {
          this._activeTarget = t2, this._clear();
          const e2 = Ve.split(",").map((e3) => `${e3}[data-bs-target="${t2}"],${e3}[href="${t2}"]`), i2 = Y.findOne(e2.join(","), this._config.target);
          i2.classList.add(Ke), i2.classList.contains("dropdown-item") ? Y.findOne(".dropdown-toggle", i2.closest(".dropdown")).classList.add(Ke) : Y.parents(i2, ".nav, .list-group").forEach((t3) => {
            Y.prev(t3, ".nav-link, .list-group-item").forEach((t4) => t4.classList.add(Ke)), Y.prev(t3, ".nav-item").forEach((t4) => {
              Y.children(t4, ".nav-link").forEach((t5) => t5.classList.add(Ke));
            });
          }), $.trigger(this._scrollElement, "activate.bs.scrollspy", { relatedTarget: t2 });
        }
        _clear() {
          Y.find(Ve, this._config.target).filter((t2) => t2.classList.contains(Ke)).forEach((t2) => t2.classList.remove(Ke));
        }
        static jQueryInterface(t2) {
          return this.each(function() {
            const e2 = Ye.getOrCreateInstance(this, t2);
            if ("string" == typeof t2) {
              if (void 0 === e2[t2])
                throw new TypeError(`No method named "${t2}"`);
              e2[t2]();
            }
          });
        }
      }
      $.on(window, "load.bs.scrollspy.data-api", () => {
        Y.find('[data-bs-spy="scroll"]').forEach((t2) => new Ye(t2));
      }), v(Ye);
      const Qe = "active", Ge = "fade", Ze = "show", Je = ".active", ti = ":scope > li > .active";
      class ei extends R {
        static get NAME() {
          return "tab";
        }
        show() {
          if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.classList.contains(Qe))
            return;
          let t2;
          const e2 = r(this._element), i2 = this._element.closest(".nav, .list-group");
          if (i2) {
            const e3 = "UL" === i2.nodeName || "OL" === i2.nodeName ? ti : Je;
            t2 = Y.find(e3, i2), t2 = t2[t2.length - 1];
          }
          const s2 = t2 ? $.trigger(t2, "hide.bs.tab", { relatedTarget: this._element }) : null;
          if ($.trigger(this._element, "show.bs.tab", { relatedTarget: t2 }).defaultPrevented || null !== s2 && s2.defaultPrevented)
            return;
          this._activate(this._element, i2);
          const n2 = () => {
            $.trigger(t2, "hidden.bs.tab", { relatedTarget: this._element }), $.trigger(this._element, "shown.bs.tab", { relatedTarget: t2 });
          };
          e2 ? this._activate(e2, e2.parentNode, n2) : n2();
        }
        _activate(t2, e2, i2) {
          const s2 = (!e2 || "UL" !== e2.nodeName && "OL" !== e2.nodeName ? Y.children(e2, Je) : Y.find(ti, e2))[0], n2 = i2 && s2 && s2.classList.contains(Ge), o2 = () => this._transitionComplete(t2, s2, i2);
          s2 && n2 ? (s2.classList.remove(Ze), this._queueCallback(o2, t2, true)) : o2();
        }
        _transitionComplete(t2, e2, i2) {
          if (e2) {
            e2.classList.remove(Qe);
            const t3 = Y.findOne(":scope > .dropdown-menu .active", e2.parentNode);
            t3 && t3.classList.remove(Qe), "tab" === e2.getAttribute("role") && e2.setAttribute("aria-selected", false);
          }
          t2.classList.add(Qe), "tab" === t2.getAttribute("role") && t2.setAttribute("aria-selected", true), f(t2), t2.classList.contains(Ge) && t2.classList.add(Ze);
          let s2 = t2.parentNode;
          if (s2 && "LI" === s2.nodeName && (s2 = s2.parentNode), s2 && s2.classList.contains("dropdown-menu")) {
            const e3 = t2.closest(".dropdown");
            e3 && Y.find(".dropdown-toggle", e3).forEach((t3) => t3.classList.add(Qe)), t2.setAttribute("aria-expanded", true);
          }
          i2 && i2();
        }
        static jQueryInterface(t2) {
          return this.each(function() {
            const e2 = ei.getOrCreateInstance(this);
            if ("string" == typeof t2) {
              if (void 0 === e2[t2])
                throw new TypeError(`No method named "${t2}"`);
              e2[t2]();
            }
          });
        }
      }
      $.on(document, "click.bs.tab.data-api", '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]', function(t2) {
        ["A", "AREA"].includes(this.tagName) && t2.preventDefault(), u(this) || ei.getOrCreateInstance(this).show();
      }), v(ei);
      const ii = "toast", si = "hide", ni = "show", oi = "showing", ri = { animation: "boolean", autohide: "boolean", delay: "number" }, ai = { animation: true, autohide: true, delay: 5e3 };
      class li extends R {
        constructor(t2, e2) {
          super(t2), this._config = this._getConfig(e2), this._timeout = null, this._hasMouseInteraction = false, this._hasKeyboardInteraction = false, this._setListeners();
        }
        static get DefaultType() {
          return ri;
        }
        static get Default() {
          return ai;
        }
        static get NAME() {
          return ii;
        }
        show() {
          $.trigger(this._element, "show.bs.toast").defaultPrevented || (this._clearTimeout(), this._config.animation && this._element.classList.add("fade"), this._element.classList.remove(si), f(this._element), this._element.classList.add(ni), this._element.classList.add(oi), this._queueCallback(() => {
            this._element.classList.remove(oi), $.trigger(this._element, "shown.bs.toast"), this._maybeScheduleHide();
          }, this._element, this._config.animation));
        }
        hide() {
          this._element.classList.contains(ni) && ($.trigger(this._element, "hide.bs.toast").defaultPrevented || (this._element.classList.add(oi), this._queueCallback(() => {
            this._element.classList.add(si), this._element.classList.remove(oi), this._element.classList.remove(ni), $.trigger(this._element, "hidden.bs.toast");
          }, this._element, this._config.animation)));
        }
        dispose() {
          this._clearTimeout(), this._element.classList.contains(ni) && this._element.classList.remove(ni), super.dispose();
        }
        _getConfig(t2) {
          return t2 = { ...ai, ...X.getDataAttributes(this._element), ..."object" == typeof t2 && t2 ? t2 : {} }, h(ii, t2, this.constructor.DefaultType), t2;
        }
        _maybeScheduleHide() {
          this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => {
            this.hide();
          }, this._config.delay)));
        }
        _onInteraction(t2, e2) {
          switch (t2.type) {
            case "mouseover":
            case "mouseout":
              this._hasMouseInteraction = e2;
              break;
            case "focusin":
            case "focusout":
              this._hasKeyboardInteraction = e2;
          }
          if (e2)
            return void this._clearTimeout();
          const i2 = t2.relatedTarget;
          this._element === i2 || this._element.contains(i2) || this._maybeScheduleHide();
        }
        _setListeners() {
          $.on(this._element, "mouseover.bs.toast", (t2) => this._onInteraction(t2, true)), $.on(this._element, "mouseout.bs.toast", (t2) => this._onInteraction(t2, false)), $.on(this._element, "focusin.bs.toast", (t2) => this._onInteraction(t2, true)), $.on(this._element, "focusout.bs.toast", (t2) => this._onInteraction(t2, false));
        }
        _clearTimeout() {
          clearTimeout(this._timeout), this._timeout = null;
        }
        static jQueryInterface(t2) {
          return this.each(function() {
            const e2 = li.getOrCreateInstance(this, t2);
            if ("string" == typeof t2) {
              if (void 0 === e2[t2])
                throw new TypeError(`No method named "${t2}"`);
              e2[t2](this);
            }
          });
        }
      }
      return F(li), v(li), { Alert: q, Button: U, Carousel: at, Collapse: mt, Dropdown: Ht, Modal: he, Offcanvas: me, Popover: Fe, ScrollSpy: Ye, Tab: ei, Toast: li, Tooltip: $e };
    });
  }
});
export default require_bootstrap_min();
/*! Bundled license information:

bootstrap/dist/js/bootstrap.min.js:
  (*!
    * Bootstrap v5.1.3 (https://getbootstrap.com/)
    * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
    * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
    *)
*/
//# sourceMappingURL=bootstrap_dist_js_bootstrap__min.js.map
